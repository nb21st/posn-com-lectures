### มองเห็นประสิทธิภาพ ได้ด้วย
## TIME COMPLEXITY

notes:
Time Complexity - เป็นเรื่องที่เจอตอนแรกผมคิดว่ามันจะไม่ได้ใช้ เพราะว่าผมเอาแต่โฟกัสว่า "ขอแค่เขียนโค๊ดให้ผ่านพอ เรื่องประสิทธิภาพไม่จำเป็นต้องรู้" แต่สุดท้ายผมมองว่าเรื่องนี้จำเป็น เพราะมันจะช่วยให้เรามีเหตุผลกับการแก้ไขโค๊ดให้เร็วมากขึ้น แถมมันจะช่วยให้เราอ่านโจทย์แล้วคาดเดาได้ ว่าผลลัพท์คำตอบของเรามันจะต้องมีประสิทธิภาพแค่ไหน

---
### ปัญหา

![time_limit_exceeded0](/Assets/time_limit_exceeded0.png)

notes:
Time Limit Exceed เป็นสิ่งที่ทุกคนต้องเจอ ไม่ว่าจะเขียนโปรแกรมได้ถูกหรือผิด ถ้าเขียนได้ไม่มีประสิทธิภาพมากพอ สำหรับข้อจำกัดของโจทย์ (จำนวน memory, เวลาจำกัด) คำตอบเราก็จะถูกปัดตกทันที - อาจจะได้คะแนนมานิดหน่อย แต่ก็ต้องมานั่งลื้อวิธีเขียนกันใหม่ให้มันมีประสิทธิภาพเพิ่มมากขึ้นอยู่ดี - แต่ถ้าหากเราไม่รู้ว่าทำยังไงให้เขียนโค๊ดมีประสิทธิภาพมากขึ้นมันคุณก็จะเป็นแบบผม

---
![time_limit_exceeded1](/Assets/time_limit_exceeded1.png)

notes:
อันนี้จะเป็นช่วงเวลาหลังที่ผมพึ่งจบสอวน.คอม ค่าย 1 ผมเคยมาติดกับปัญหา Time Limit Exceed เป็นเวลา 1 ชั่วโมง - บอกเลยว่ามันบ้ามาก แก้แล้วแก้อีก "ทำไมมันช้าเกินไป!" ลองแม้กระทั่งเปลี่ยนเวอร์ชั่นภาษาไปมา ซึ่งไม่ควรส่งผลมากขนาดนั้นด้วยซ้ำ - อย่างที่ผมบอกไป ตอนแรกผมคิดว่าขอแค่เขียนโค๊ดให้เป็นพอ เรื่องนี้ไม่จำเป็นต้องสนใจ และผมก็ต้องจ่ายค่าโง่ไป 1 ชั่วโมงกว่าๆ เพราะผมไม่รู้ว่าสิ่งที่ผมต้องทำ คือลื้อโค๊ดทิ้งแล้วใช้วิธีอื่นที่มีประสิทธิภาพมากกว่า - แต่ว่าผมจะรู้ได้อย่างไร ว่าโค๊ดแบบไหนมันมีประสิทธิภาพกว่า ถ้าผมไม่มีแม่กระทั่งหน่วยวัด

---
> คุณไม่สามารถบริหารหรือจัดการมันได้
> ถ้าคุณไม่สามารถวัดค่าของมันได้

\- Peter Drucker

notes:
อันนี้เป็นคำพูดที่โด่งดังในวงการนักบริหาร แต่ผมมองว่าความหมายโดยนัยของมันนั้น ค่อนข้างตรงกับการที่เราตัดสินใจเลือกออกอริทึม โดยยึดจากข้อจากข้อจำกัดของโจทย์ ถ้าเรามีหน่วยวัดที่ชัดเจน เราก็จะมีแนวทางการแก้โจทย์ที่ชัดเจน

---
### Big O Notation

![big_o](/Assets/big_o.png)

notes:
Big O Notation - เป็นสูตรที่อธิบายอัตตราการเติบโตของจำนวนการดำเนินงานภายในออกอริทึมเมื่อต้องรับค่าข้อมูลในจำนวนต่างๆ

---
### สูตรคือ O(...)
มักมี n เป็นจำนวน input

notes:
วิธีอ่านสูตรง่ายๆ ก็จะเป็น O วงเล็บฟังค์ชั่น ซึ่ง n มักจะแทนจำนวน input แต่พูดอย่างเดียวคงไม่เห็นภาพ ต้องเห็นของจริง

---
#### ทุกการดำเนินการที่เป็นค่าคงที่ คือ O(1)
```cpp
int i = 10; // O(1)
i = 100'000;    // O(1)
cout << i; // O(1)
```

notes:
ทุกอย่างมันเริ่มด้วยงานง่ายๆ อย่างเช่นการประกาศตัวแปรด้วยค่าคงที่ แทนค่าคงที่ หรือพิมพ์ค่าคงที่ ทุกอย่างนี้ทำงานเพียงแค่ 1 ครั้งแล้วก็จบ ไม่มีการเติบโตทางจำนวนทั้งสิ้น

---
#### O(n) เพราะ n เป็นตัวแปร/input
```cpp
for (int i = 0; i < n; i++) {
  // โค๊ด O(1)
}
```

#### O(n^2)
```cpp
for (int i = 0; i < n; i++) {
  for (int j = 0; j < n; j++) {
    // โค๊ด O(1)
  }
}
```

notes:
จนกระทั่งเราเริ่มมี Loop เกิดขึ้น แล้วจำนวน Loop นั้นขึ้นอยู่กับตัวแปรที่มีค่าไม่แน่นอน ก็คือค่า n ซึ่งเป็นตัวแทน Input - อย่างที่เห็นในตัวอย่างที่ 1 คือภายใน Loop จะมีโค๊ดที่รันแบบ O(1) - แต่จำนวนที่โค๊ด O(1) จะรันนั้นมีจำนวนเท่ากับ n จึงกลายเป็น O(n) -- ในตัวอย่างที่ 2 เนื่องจากเป็น Loop n แบบซ้อนกัน 2 อัน จึงมีค่าเป็น O(n^2)

---
### วัดที่อัตราการเติบโต ไม่ใช่ค่าจริง

---
### O(n) เพราะอัตตราการเติบโตเป็นเส้นตรงเหมือนกัน
```cpp
for (int i = 0; i < 10*n; i++) {
  // โค๊ด O(1)
}
```

```cpp
for (int i = 0; i < n+5; i++) {
  // โค๊ด O(1)
}
```

```cpp
for (int i = 0; i < n + 300'000; i++) {
  // โค๊ด O(1)
}
```

notes:
Big O Notation ไม่สนว่าค่าจริงมันคือ 10n, n+5, n+300,000 เพราะสุดท้ายแล้ว อัตตราการเติมโตของโค๊ดพวกนี้ ก็เป็นแบบสมการเส้นตรง

---
### O(n^2) เพราะอัตตราการเติบโตเป็นกำลังสองเหมือนกัน
```cpp
for (int i = 0; i < n*2; i++) {
  for (int j = 0; j < n*3; j++) {
    // โค๊ด O(1)
  }
}
```

```cpp
for (int i = 0; i < n*n*14; i++) {
  // โค๊ด O(1)
}
```

notes:
เช่นเดียวกับตัวแรก ที่ค่าจริงๆของมันคือ 2n * 3n = 6n^2 ซึ่งสิ่งเดียวที่เราสนใจคืออัตตราการเติมโต จึงมองเป็น O(n^2)

---
### Big O Notation จะใช้เคสที่แย่ที่สุดเสมอ
---
#### O(n^2)
```cpp
// O(n)
for (int i = 0; i < n; i++) {
  // โค๊ด O(1)
}
// O(n^2)
for (int i = 0; i = n; i++) {
  for (int j = 0; j = n; j++) {
    // โค๊ด O(1)
  }
}
// O(1)
for (int i = 0; i < 500'000; i++) { 
  // โค๊ด O(1)
}
```

notes:
ในกรณีที่มี O หลายตัวเรียงกัน ให้นับ O ที่มีค่าสูงที่สุด อย่างในกรณีนี้ จะได้เท่ากับว่าโค๊ดทั้งหมดนี้มีค่าเป็น O(n^2)

---
### กรณีมีหลายตัวแปร
#### O(n * m)
```cpp
for (int i = 0; i < n; i++) {
  for (int j = 0; i < m; j++) {
    // โค๊ด O(1)
  }
}
```

notes:
บางทีเราอาจจะต้องใช้หลายตัวแปรอย่างเช่นออกอริทึมกราฟที่เราจะได้เรียนกัน ก็ให้นับตัวแปรทั้งหมดไปด้วย

---
### วิธีหา O ฟังก์ชั่นหรือออกอริทึมที่ถูกคิดค้นไว้แล้ว
- ฟังก์ชั่น Standard Template Library อย่างเช่น [sort()](https://en.cppreference.com/w/cpp/algorithm/sort.html) หาดูได้จาก [cppreference.com](https://en.cppreference.com)
- ออกอริทึมที่เป็นที่นิยมอย่างเช่น [Binary Search](https://en.wikipedia.org/wiki/Binary_search) หรือ [Dikstra's Algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)
- STL Containers: [บทความ GeeksForGeeks](https://www.geeksforgeeks.org/analysis-of-time-and-space-complexity-of-stl-containers/), [alyssaq.github.io/stl-complexities/](https://alyssaq.github.io/stl-complexities/)

---
## คาดการ Big O ของคำตอบด้วยข้อจำกัดของโจทย์
![solution_complexity_estimation](/Assets/solution_complexity_estimation.png)

notes:
ถ้าสมมุติว่าโจทย์ให้เวลาโปรแกรมเรา 1 วินาที นี่จะเป็น Time Complexity ที่คาดคะเนได้ ไม่จำเป็นต้องจำให้แม่นยำอะไรมาก แค่รู้ไว้ว่าถ้าจำนวน n เรามีสัก 5 แสนเราก็น่าจะต้องหาคำตอบที่ใช้ O(n log n) หรือ O(n) ขอย้ำว่าอันนี้เป็นแค่คาดคะเน เพราะว่าแม้แต่ Big O Notation ก็ไม่ได้นับค่าจริงอย่างเช่น n/2 หรือ n * 5 ซึ่งมันก็ส่งผลให้คาดเคลื่อนได้ ให้มองไว้เป็นแนวทาง

---
### ตัวอย่างโจทย์
## [Maximum Subarray Sum](https://cses.fi/problemset/task/1643/)
---
### Algorithm 1
```cpp
  long long best = INT_MIN;
  for (int i = 0; i < n; i++) {
    for (int j = i; j < n; j++) {
      long long sum = 0;
      for (int k = i; k <= j; k++) {
        sum += array[k];
      }
      best = max(best, sum);
    }
  }

  cout << best << "\n";
}

```
### O(n^3)

---
### Algorithm 2
```cpp
  long long best = INT_MIN;
  for (int i = 0; i < n; i++) {
    long long sum = 0;
    for (int j = i; j < n; j++) {
      sum += array[j];
      best = max(best, sum);
    }
  }
  
  cout << best << "\n";
}
```
### O(n^2)
---
### Algorithm 3
```cpp
  long long best = INT_MIN, sum = 0;
  for (int i = 0; i < n; i++) {
    sum = max(array[i], sum + array[i]);
    best = max(best, sum);
  }

  cout << best << "\n";
}
```
### O(n)
---
## เปรียบเทียบเวลาจริง
![efficiency_comparison](/Assets/efficiency_comparison.png)
- Algorithm 1 = O(n^3)
- Algorithm 2 = O(n^2)
- Algorithm 3 = O(n)

---
## Thank You
